step 1:

ردیف | محل اعمال تغییرات (کلاس/واسط) | عنوان تغییر | شرحی کوتاه از تغییر
--- | --- | --- | ---
1 | OrderService | افزودن تابع پرداخت تلفنی | افزودن یک تابع void با عنوان phoneOrderPayment
2 | OrderService | افزودن تابع ثبت سفارش تلفتی | افزودن یک تابع void با عنوان phoneOrderRegister

مجموع تعداد تغییرات: 2



step2:

| اصل SOLID | محل اعمال تغییرات (کلاس/واسط) | موارد تحقق | موارد نقض |
| --- | --- | --- | --- |
| Single Responsibility | Main | کلاس‌ها به نظر می‌آیند که هرکدام یک مسئولیت مشخص دارند | کلاس Main به نظر می‌رسد که یک مسئولیت بیش از حد دارد؛ به عنوان مثال، دریافت ورودی از کاربر و مدیریت جریان برنامه |
| Open-Close Principle (OCP) | - | با اضافه کردن PhoneOrderService، برنامه قابلیت توسعه و افزودن سرویس‌های جدید را دارد | در صورت افزودن سرویس جدید، ممکن است نیاز به تغییر در کلاس Main باشد |
| Liskov Substitution Principle | - | کلاس‌های OnlineOrderService و OnSiteOrderService قابل جایگزینی هستند و می‌توانند به جای یکدیگر استفاده شوند | اگر PhoneOrderService اضافه شود، ممکن است تفاوت‌های بیشتری با سایر سرویس‌ها داشته باشد و جایگزینی آسان نباشد |
| Interface Segregation Principle | OrderService | واسط OrderService مختصر و مرتبط به هر کلاس خاص است | اگر در آینده توابع جدیدی به OrderService افزوده شود، کلاس‌هایی که از این واسط استفاده می‌کنند، ممکن است نیاز به پیاده‌سازی توابع اضافه داشته باشند |
| Dependency Inversion Principle | Main | کلاس Main از وابستگی به جزییات پایینی مانند OnlineOrderService و OnSiteOrderService جلوگیری کرده است | اگر یک سرویس جدید (مانند PhoneOrderService) اضافه شود، ممکن است نیاز به تغییر در کد Main باشد |

راهکار:

| اصل مربوطه (از اصول SOLID) | علت نقض | راه حل پیشنهادی |
| --- | --- | --- |
| Single Responsibility | کلاس Main به نظر می‌رسد که یک مسئولیت بیش از حد دارد؛ به عنوان مثال، دریافت ورودی از کاربر و مدیریت جریان برنامه | ایجاد یک مدیریت جریان برنامه مستقل به عنوان یک کلاس جدید |
| Open-Close Principle (OCP) | در صورت افزودن سرویس جدید، ممکن است نیاز به تغییر در کلاس Main باشد | استفاده از الگوهای طراحی مانند Factory Pattern |
| Liskov Substitution Principle | اگر PhoneOrderService اضافه شود، ممکن است تفاوت‌های بیشتری با سایر سرویس‌ها داشته باشد و جایگزینی آسان نباشد | ایجاد واسطهای جداگانه برای هر نوع سفارش |
| Interface Segregation Principle | اگر در آینده توابع جدیدی به OrderService افزوده شود، کلاس‌هایی که از این واسط استفاده می‌کنند، ممکن است نیاز به پیاده‌سازی توابع اضافه داشته باشند | ایجاد واسطهای جداگانه برای هر کلاس مشتری و هر کلاس سفارش |
| Dependency Inversion Principle | اگر یک سرویس جدید (مانند PhoneOrderService) اضافه شود، ممکن است نیاز به تغییر در کد Main باشد | استفاده از الگوهای طراحی مانند Dependency Injection و Inversion of Control Container |



