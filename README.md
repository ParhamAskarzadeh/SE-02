Parham Askarzadeh,
Ghazaal Taghavi


Report:

step 1:

ردیف | محل اعمال تغییرات (کلاس/واسط) | عنوان تغییر | شرحی کوتاه از تغییر
--- | --- | --- | ---
1 | OrderService | افزودن تابع پرداخت تلفنی | افزودن یک تابع void با عنوان phoneOrderPayment
2 | OrderService | افزودن تابع ثبت سفارش تلفتی | افزودن یک تابع void با عنوان phoneOrderRegister

مجموع تعداد تغییرات: 2



step2:

| اصل SOLID | محل اعمال تغییرات (کلاس/واسط) | موارد تحقق | موارد نقض |
| --- | --- | --- | --- |
| Single Responsibility | Main | کلاس‌ها به نظر می‌آیند که هرکدام یک مسئولیت مشخص دارند | کلاس Main به نظر می‌رسد که یک مسئولیت بیش از حد دارد؛ به عنوان مثال، دریافت ورودی از کاربر و مدیریت جریان برنامه |
| Open-Close Principle (OCP) | - | با اضافه کردن PhoneOrderService، برنامه قابلیت توسعه و افزودن سرویس‌های جدید را دارد | در صورت افزودن سرویس جدید، ممکن است نیاز به تغییر در کلاس Main باشد |
| Liskov Substitution Principle | - | کلاس‌های OnlineOrderService و OnSiteOrderService قابل جایگزینی هستند و می‌توانند به جای یکدیگر استفاده شوند | اگر PhoneOrderService اضافه شود، ممکن است تفاوت‌های بیشتری با سایر سرویس‌ها داشته باشد و جایگزینی آسان نباشد |
| Interface Segregation Principle | OrderService | واسط OrderService مختصر و مرتبط به هر کلاس خاص است | اگر در آینده توابع جدیدی به OrderService افزوده شود، کلاس‌هایی که از این واسط استفاده می‌کنند، ممکن است نیاز به پیاده‌سازی توابع اضافه داشته باشند |
| Dependency Inversion Principle | Main | کلاس Main از وابستگی به جزییات پایینی مانند OnlineOrderService و OnSiteOrderService جلوگیری کرده است | اگر یک سرویس جدید (مانند PhoneOrderService) اضافه شود، ممکن است نیاز به تغییر در کد Main باشد |

راهکار:

| اصل مربوطه (از اصول SOLID) | علت نقض | راه حل پیشنهادی |
| --- | --- | --- |
| Single Responsibility | کلاس Main به نظر می‌رسد که یک مسئولیت بیش از حد دارد؛ به عنوان مثال، دریافت ورودی از کاربر و مدیریت جریان برنامه | ایجاد یک مدیریت جریان برنامه مستقل به عنوان یک کلاس جدید |
| Open-Close Principle (OCP) | در صورت افزودن سرویس جدید، ممکن است نیاز به تغییر در کلاس Main باشد | استفاده از الگوهای طراحی مانند Factory Pattern |
| Liskov Substitution Principle | اگر PhoneOrderService اضافه شود، ممکن است تفاوت‌های بیشتری با سایر سرویس‌ها داشته باشد و جایگزینی آسان نباشد | ایجاد واسطهای جداگانه برای هر نوع سفارش |
| Interface Segregation Principle | اگر در آینده توابع جدیدی به OrderService افزوده شود، کلاس‌هایی که از این واسط استفاده می‌کنند، ممکن است نیاز به پیاده‌سازی توابع اضافه داشته باشند | ایجاد واسطهای جداگانه برای هر کلاس مشتری و هر کلاس سفارش |
| Dependency Inversion Principle | اگر یک سرویس جدید (مانند PhoneOrderService) اضافه شود، ممکن است نیاز به تغییر در کد Main باشد | استفاده از الگوهای طراحی مانند Dependency Injection و Inversion of Control Container |


step 4:

۱. با فرض اجرای گام ۱ (پس از انجام گام‌های ۲ و ۳)، از انجام تغییرات مربوط به "افزودن تابع پرداخت تلفنی" در جدول گام ۱ معاف می‌شوید، زیرا این تغییر مربوط به توسعه قابلیت سفارش تلفنی است که در گام ۱ انجام شده است.

۲. تعداد تغییرات مورد نیاز برای اجرای گام ۱ بستگی به تعداد و نوع تغییرات اضافه شده است. در این حالت، با توجه به تغییرات اعمال شده در Main، PhoneOrderService و OrderService، می‌توان به دو تغییر مهم اشاره کرد: اضافه کردن توابع phoneOrderRegister و phoneOrderPayment به OrderService و نیز ایجاد PhoneOrderService.


step 5:

از این گام، قابلیت سفارش تلفنی به برنامه اضافه شده است، و این تغییرات بر اساس اصول SOLID اعمال شده‌اند. این تغییرات از اهمیت اصل Interface Segregation و Dependency Inversion بهره مند شده‌اند.

با رعایت اصل Interface Segregation، توابع مربوط به سفارش تلفنی به واسطه PhoneOrderService افزوده شدند، بدون اینکه تغییراتی به OrderService واقعی اعمال شود. این اصل امکان افزودن ویژگی‌های جدید (مانند سفارش تلفنی) را بدون تغییر در واسطه‌های موجود فراهم می‌کند.

همچنین، با رعایت اصل Dependency Inversion و افزودن PhoneOrderService، وابستگی به OrderService کاهش یافته است و یک وابستگی به سطح بالاتر واسطه ایجاد شده است. این امر موجب افزایش انعطاف‌پذیری برنامه می‌شود و امکان جایگزینی ماژول‌ها به راحتی فراهم می‌آید.

به طور کلی، کاربرد صحیح اصول SOLID در گام‌های ۳ و ۴ باعث افزایش خوانایی، انعطاف‌پذیری و قابلیت توسعه برنامه می‌شود و این امکان را فراهم می‌کند که تغییرات اضافی اعمال شوند بدون تأثیر منفی بر سایر بخش‌های برنامه.
